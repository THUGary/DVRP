#!/usr/bin/env python3
"""
Generate an API summary (Markdown) of Python files in the repository.

This script walks the workspace, parses .py files with the AST module,
and extracts module docstrings, top-level classes (with methods) and
top-level functions. It writes `api_summary.md` at the repository root.

Usage: python scripts/generate_api.py
"""
import ast
import os
from typing import List, Optional


def safe_unparse(node: ast.AST) -> str:
    try:
        return ast.unparse(node)
    except Exception:
        return "<expr>"


def format_args(args: ast.arguments) -> str:
    parts: List[str] = []
    # regular args
    arg_names = [a.arg for a in args.posonlyargs] if hasattr(args, 'posonlyargs') else []
    arg_names += [a.arg for a in args.args]
    defaults = [None] * (len(arg_names) - len(args.defaults)) + list(args.defaults)
    for name, default in zip(arg_names, defaults):
        if default is None:
            parts.append(name)
        else:
            parts.append(f"{name}={safe_unparse(default)}")

    # vararg
    if args.vararg:
        parts.append(f"*{args.vararg.arg}")

    # kwonly args
    for name, default in zip([a.arg for a in args.kwonlyargs], args.kw_defaults):
        if default is None:
            parts.append(name)
        else:
            parts.append(f"{name}={safe_unparse(default)}")

    # kwarg
    if args.kwarg:
        parts.append(f"**{args.kwarg.arg}")

    return ", ".join(parts)


def summarize_file(path: str) -> Optional[str]:
    try:
        with open(path, 'r', encoding='utf-8') as f:
            src = f.read()
    except Exception as e:
        return f"**Error reading file**: {e}\n"

    try:
        module = ast.parse(src)
    except SyntaxError as e:
        return f"**SyntaxError while parsing**: {e}\n"

    lines: List[str] = []
    lines.append(f"### {path}\n")

    mod_doc = ast.get_docstring(module)
    if mod_doc:
        doc = mod_doc.replace('\n', ' ')
        lines.append(f"> {doc}\n")

    classes = [n for n in module.body if isinstance(n, ast.ClassDef)]
    funcs = [n for n in module.body if isinstance(n, ast.FunctionDef)]

    if classes:
        lines.append("**Classes:**\n")
        for c in classes:
            bases = [safe_unparse(b) for b in c.bases]
            base_list = f"({', '.join(bases)})" if bases else ""
            lines.append(f"- {c.name}{base_list}")
            c_doc = ast.get_docstring(c)
            if c_doc:
                lines.append(f"  - doc: {c_doc.splitlines()[0]}")

            methods = [m for m in c.body if isinstance(m, ast.FunctionDef)]
            for m in methods:
                sig = format_args(m.args)
                m_doc = ast.get_docstring(m)
                lines.append(f"  - def {m.name}({sig})")
                if m_doc:
                    lines.append(f"    - doc: {m_doc.splitlines()[0]}")
        lines.append("")

    if funcs:
        lines.append("**Functions:**\n")
        for f in funcs:
            sig = format_args(f.args)
            f_doc = ast.get_docstring(f)
            lines.append(f"- def {f.name}({sig})")
            if f_doc:
                lines.append(f"  - doc: {f_doc.splitlines()[0]}")
        lines.append("")

    return "\n".join(lines)


def should_skip_dir(d: str) -> bool:
    skip = {'__pycache__', '.git', 'checkpoints', 'runs', '.ipynb_checkpoints', 'downloads'}
    return d in skip


def main():
    root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
    out_lines: List[str] = []
    out_lines.append("# API summary\n")
    out_lines.append("Generated by `scripts/generate_api.py`\n")

    for dirpath, dirnames, filenames in os.walk(root):
        # mutate dirnames in-place to skip
        dirnames[:] = [d for d in dirnames if not should_skip_dir(d)]

        for fname in filenames:
            if not fname.endswith('.py'):
                continue
            path = os.path.join(dirpath, fname)
            # skip the generated file itself if present
            if os.path.basename(path) == 'generate_api.py':
                # still include other scripts
                pass
            rel_path = os.path.relpath(path, root)
            summary = summarize_file(path)
            if summary:
                out_lines.append(summary)

    out_path = os.path.join(root, 'api_summary.md')
    with open(out_path, 'w', encoding='utf-8') as f:
        f.write('\n'.join(out_lines))

    print(f"Wrote {out_path}")


if __name__ == '__main__':
    main()
